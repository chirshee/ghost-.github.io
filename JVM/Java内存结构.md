#  Java内存结构

## 运行时数据区域

![java运行时数据区.jpg](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzgwof66h1j30d60anac7.jpg)

**线程私有的：**

* 程序计数器
* 虚拟机栈
* 本地方法栈

**线程共享的：**

* 堆
* 方法区
* 直接内存

#### 程序计数器

> 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码行号指示器。**字节码解释器工作时通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都依赖这个计数器来完成。**
>
> **为了线程切换后能恢复到正确的执行位置，每条线程都要有独立的程序计数器，各个线程之间计数器互相不影响，独立储存，所以我们说程序计数器是线程私有的**
>
> **程序计数器的主要作用：**
>
> 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
> 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程切换回来的时候，知道上次执行到什么位置。
>
> **程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期和线程的生命周期是同步的**

#### java虚拟机栈

> java虚拟机栈和程序计数器是一样的，是线程私有的，声明周期与线程生命周期相同。**描述的是java方法执行的内存模型**
>
> **java虚拟机粗略分为堆内存和栈内存，其中栈内存指的就是虚拟机栈。**
>
> **虚拟机栈是由一个个栈帧组成的，每一个栈帧中都有:局部变量表，操作数栈，动态链接，方法出口信息**
>
> **局部变量表：**主要储存编译器可知的各种**数据类型**、**对象引用**
>
> **java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError**
>
> * **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
> * **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

#### 本地方法栈

> 与java虚拟机栈的作用十分相似，**区别：虚拟机栈为java虚拟机执行java方法；本地方法栈则为虚拟机使用到的Native方法服务。在HotSpot虚拟机中将两者合二为一**
>
> 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
>
> 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

#### 堆

> java虚拟机所管理的内存最大一块，java堆是所有线程共享的一块内存区域，，在虚拟机启动时创建。**此内存区唯一的目的就是存放对象实例，几乎所有的实例对象已经数组都在这里分配内存。**java堆是垃圾收集器管理的主要区域，因此也被称为**GC堆（Garbage Collected Heap）**,从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以java堆还可以细分为：**新生代和老年代**:再细致一点有：Eden空间、From Survivor、To Survivor空间等.**进一步划分的目的是更好的回收内存，或者更快的分配内存**

![堆内存的划分.jpg](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzhpbcvpv6j30gn06yq2w.jpg)

**在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）**

#### 方法区：

> **方法区是线程共的区域，用于储存已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。**
>
> 相对而言，垃圾回收行为在这个区域是比较少出现的，但是并非数据进入方法区就永久存在了

#### 运行时常量池

> 运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放各种编译器生成的自面量和符号引用）
>
> **当运行时常量池无法在申请到内存的时候，会出现OutOfMemory异常**
>
> **JDK1.7以后，已经将运行时常量池从方法区中移了出来，在堆区开辟了一块内存来存放运行时常量池**

![运行时常量池.jpg](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fzhptyxb8mj31a10nvjtf.jpg)

#### 直接内存

> 直接内存并不是虚拟机运行时区域的一部分，也不是虚拟机运行规范的内存区域，但是这部分被频繁的使用，并且也可能导致OutOfMemoryError异常
>
> JDK1.4中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。
>
> 本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## HotSpot虚拟机对象探秘

### 对象的创建

![创建对象.jpg](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzhqdsh3eyj30fy0f5myd.jpg)

（1）**类加载检查：** 虚拟机遇到一条new指令时，首先将去检查这个指令的参数能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过，解析过，初始化过。如果没有就先进行类加载。

（2）**分配内存：** 在**类加载检查**通过之后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成之后便可确定，为对象分配空间的任务等于把一块确定大小的内存从堆内存中划分出来。 **分配方式：**有**指针碰撞**和**空闲指针**两种，**选择哪一种分配方式由java堆是否规整来确定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**

**两种内存分配的方式：**

> 选择哪一种分配方式由java堆是否规整来确定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定，也就是GC收集器的算法是**"标记-清除"算法**还是**“标记整理”算法**，ps:复制算法也是的规整的

**内存分配高并发问题**

> 创建对象的时候，存在线程安全问题，作为虚拟机来讲，必须要保证线程的安全，通常，虚拟机采用两种方法来保证线程安全

* **CAS+失败重试：** CAS是乐观锁的一种实现方式。所谓的乐观锁就是，每次不加锁而假设没有冲突而去完成某种操作，如果因为冲突失败就重试，知道成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**

* **TLAB：** 为每一个线程预先在Eden区分配一块内存，JVM在给对象分配内存时，首先在TLAB分配，当对象大域TLAB中的剩余内存或TLAB的内存已经用尽的时候，在采用上述的CAS进行内存分配。

（3）**初始化零值：** 内存分配完成之后，虚拟机将分配到的内存空间都初始化为0（不包括对象头），这一步操作保证了对象在实例字段在java代码中可以不赋初始值就可以直接使用，程序能直接访问到这些基本数据类型所对应的0值。

（4）**设置对象头：** 初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

（5）**执行init方法：**  在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

#### **探究对象的结构（三部分）：**

**Header:（对象头）mark  word**

- 自身运行时数据：

  - 哈希值
  - GC分代年龄
  - 锁状态标志
  - 线程持有的锁
  - 偏向线程id
  - 偏向时间戳

- 类型指针

 - 即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

 **实例数据(InstanceData)**: **实例数据部分是对象真正存储的有效信息 **，也是在程序中所定义的各种类型的字段内容。

**对齐填充Padding: **数据填充的作用。

#### 对象的访问定位

> 建立对象就是为了使用对象的，Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有两个：**使用句柄**和**直接指针**。

- 使用句柄：引用类型指向句柄池，找到句柄地址，通过句柄地址找到对象

  - 句柄池中存放的数据：到对象实例数据的指针，到数据类型数据的指针。
  - 使用句柄的**优点: 在对象被移动时只会改变句柄中的实例数据指针,引用地址不需要修改**

 ![通过句柄来访问对象.jpg](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzhtflrgjnj30lu0a2mzu.jpg)

- 直接指针：引用类型直接指向对象的内存区域

 - 使用直接指针的**优点**：速度比较快。

 ![通过指针直接访问.jpg](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fzhtj3p319j30la09ttb4.jpg)

