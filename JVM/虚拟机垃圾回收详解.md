#  虚拟机垃圾回收详解

## 1.如何判断对象为垃圾对象

* 引用计数法
* 可达性分析

#### 1.1引用计数法

> 给对象添加一个引用计数器，每当又一个地方引用它，计数器就加一；当引用失效，计数器就减一；任何时候计数为0的对象就不可能在被使用

这种方法实现简单，效率高，但是目前主流的虚拟机并没有选择这个方法来管理内存，**主要的原因是：**它很难解决对象之间相互循环引用的问题

#### 1.2可达性分析算法

> 这个算法就是通过一系列称为**GC Roots**的对象作为起点，从这些节点开始向下搜索，节点走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，就证明该对象是不可用的。

![可达性分析算法.jpg](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzoe6l75uoj30j609p74w.jpg)

如图：已经不可用的对象：ObjD、ObjF、ObjE

**在java中：可以作为GC Roots的对象包括以下几种：**

* 虚拟机栈中的引用的对象（栈帧中的本地方法表）
* 方法区中的类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI(Native方法)引用的对象

## 2. Java中的引用

> 无论是上述的哪种算法，判定对象是否存活都与“引用”有关。
>
> 引用分为：**强引用，软引用，弱引用，虚引用。**

* 强引用

  > 在程序代码中普遍存在的，类似`Object obj = new Oject()`这类引用，只要强引用还存在，垃圾回收器就永远不会回收掉被引用的对象。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

* 软引用

  > 用来描述一些有用但是不必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收之后还没有足够的内存，才会抛出内存溢出内存。
  >
  > 软引用可以实现内存敏感的高速缓存。
  >
  > 软引用可以和引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。

* 弱引用

  >只具有弱引用的对象拥有更短的生命周期。在垃圾回收线程扫描的它所管辖的内存区域的过程中，一旦发现只具有软引用的对象，不管当前内存空间是否充足，都会回收它的内存。但是由于垃圾回收器是一个线程有优先级很低的线程，因此不一定会很快的发现那些只具有弱引用的对象

   弱引用可以和一个引用队列联合使用，如果软引用所引用的对象被垃圾回收，java虚拟机就会把这个弱引用加入到与之关联的引用队列中

* 虚引用

  	> 虚引用并不会决定对象的生命周期
  	>
  	> 如果一个对象仅仅持有虚引用，那么就跟没有任何引用一样，在任何时候都可能被垃圾回收

  **虚引用主要用来跟踪对象的被垃圾回收的活动**

  **虚引用和软引用存在的区别：**虚引用必须要和引用队列联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，则把这个虚引用加入到与之关联的引用队列中。

**软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

#### 2.1不可达对象并非“非死不可”

> 在可达性分析算法中，不可达的对象，也并非不是“非死不可”的，这是他们处于“缓刑阶段”，要真正的宣告一个对象的死亡，至少要经历两次标记过程；
>
> 可达性分析算法的对象被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法，当对象没有覆盖finalize方法或finalize方法已经被虚拟机调用过时，虚拟机默认两种情况，没有必要执行
>
> 被判定为需要执行的对象会被放到一个对列中，进行第二次标记，除非这个对象与引用链上任何一个对象建立关联，否则真的被回收

#### 2.2如何判断一个常量是废弃常量

> 如果在常量池中存在一个字符串，如果当前没有任何String对象引用该字符串长常量的话，就说明常量是废弃常量。

#### 2.3如何判断一个类是无用的类

> 方法区怎么回收的是无用的类
>
> **一个无用的类需要满足以下三个条件：**
>
> * 该类的所有的实例都已经被回收，也就去java堆中不存在该类的任何实例
> * 加载该类的ClassLoader已经被回收
> * 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 3.垃圾回收算法

* **标记-清除算法**
* **复制算法**
* **标记-整理算法**
* **分代收集算法**

#### 3.1标记-清除算法

> 算法被分为“标记”和“清除”阶段：首先需要标记出需要回收的对象，在标记完成后，统一回收所有被标记的对象。这是最基础的回收算法

**优点：**

* 效率高

**缺点：**

* 效率问题
* 空间问题：标记清除后会产生大量的不连续碎片

![5c617995c2076.jpg](https://i.loli.net/2019/02/11/5c617995c2076.jpg)

#### 3.2复制算法

> 可以将内存分为大小相同的两块，每次只使用一块。当这一块的内存使用完后，就将还存活的对象复制到另一块中，然后再把使用的空间一次性清除掉。

![复制算法.jpg](https://i.loli.net/2019/02/11/5c617d9d5473a.jpg)

#### 3.3标记-整理算法

> 根据**老年代**的特点出的一种标记算法，标记过程仍然与“标记—清除”算法一致，但是后续步骤不是直接清除，而是让所有存活的对象向一端移动，然后直接清理掉端边界以为的内存

#### 3.4分代收集算法

> 根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代。

* **新生代中**，每次收集都有大量的对象死去，所以采用复制算法，**老年代中**，对象存活的机率比较大，所以采用“标记-清除”或者“标记-整理”算法进行垃圾回收
* **算法可以解释，HotSpot为什么分新生代和老年代**

